#ifndef ESTD_VALUE_PTR
#define ESTD_VALUE_PTR

#include <type_traits>
#include <stdexcept>
#include <memory>

namespace std
{
  /*

  this is already included in libc++

  template<class...>
  using void_t = void;

  */

  template<typename T>
  class clonable;

  template<class, class = void_t<>>
  struct is_clonable : false_type { };

  template<class T>
  struct is_clonable<T, void_t<decltype(declval<T>().clone())>> : true_type { };

  template<class T> inline
  typename enable_if<is_clonable<T&&>::value, T>::type
  clone(T && x)
  {
    cout << __PRETTY_FUNCTION__ << endl;
    return move(x.clone()); 
  }
  
  template<class T> inline
  typename enable_if<is_clonable<const T&>::value, T>::type
  clone(const T & x)
  {
    cout << __PRETTY_FUNCTION__ << endl;
    return x.clone(); 
  }
  
  template<class T> inline
  typename enable_if<is_clonable<T*>::value, T*>::type
  clone(const T * x)
  {
    cout << __PRETTY_FUNCTION__ << endl;
    return x->clone(); 
  }

  template<class T> inline
  typename enable_if<is_fundamental<T>::value, T>::type
  clone(const T & x)
  {
    cout << __PRETTY_FUNCTION__ << endl;
    T c = x;
    return x;
  }

  template<class T>
  struct value_ptr
  {
    template <typename... Args>
    explicit value_ptr(Args ...args)
    : data{new T{args...}}
    { 
      cout << __PRETTY_FUNCTION__ << endl;
    }
   
    /*
    explicit value_ptr(T x) : data{new T{x.clone()}}
    { 
      cout << __PRETTY_FUNCTION__ << endl;
    }

    explicit value_ptr(const T & x) : data{new T{x.clone()}}
    {
      cout << __PRETTY_FUNCTION__ << endl;
    }
    */

    explicit value_ptr(value_ptr &&x) : data{move(data)}
    {
      cout << __PRETTY_FUNCTION__ << endl;
    }
    
    explicit value_ptr(const value_ptr &x) : data{move(x->clone())}
    { 
      cout << __PRETTY_FUNCTION__ << endl;
    }

    value_ptr & operator=(const value_ptr &x)
    {
      data = move(x->clone());
      return *this;
      //return (*this = move(x->clone()));
    }

    value_ptr & operator=(value_ptr &&x)
    {
      cout << __PRETTY_FUNCTION__ << endl;
      data = std::move(x.data);
      return *this;
    }

    T& operator *(int) { return *data; }
    T* operator ->() { return data.get(); }
    const T* operator ->() const { return data.get(); }

    bool operator==(const value_ptr &x) const
    {
      return *data == *x.get();
    }
    
    bool operator!=(const value_ptr &x) const
    {
      return *data != *x.get();
    }

    T* get() { return data.get(); }
    const T* get() const { return data.get(); }

    template<class TT>
    value_ptr<TT> as() const
    {
      TT* p = dynamic_cast<TT*>(data.get());
      if(!p) throw std::bad_cast{};
      return move(value_ptr<TT>{move(*p)});
    }

    private:
      unique_ptr<T> data;
  };

  template<typename T>
  struct clonable
  {
    unique_ptr<T> clone() const & 
    { 
      cout << __PRETTY_FUNCTION__ << endl;
      return unique_ptr<T>{new T{*static_cast<const T*>(this)}};
    }

  };

}

#endif
